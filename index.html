<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOC 2D Torus - Dual NOC Communication Design</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SF Mono', 'Consolas', monospace;
            background: #050508;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #canvas-container { width: 100vw; height: 100vh; cursor: crosshair; }
        
        .panel {
            position: fixed;
            background: rgba(8, 8, 15, 0.95);
            border: 1px solid #2a2a40;
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .top-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        h1 { color: #00d4ff; font-size: 1.1em; white-space: nowrap; }
        
        .btn-group { display: flex; gap: 5px; }
        
        button {
            padding: 8px 14px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a28;
            color: #888;
            cursor: pointer;
            font-size: 0.8em;
            font-family: inherit;
            transition: all 0.15s;
        }
        
        button:hover { background: #252538; color: #fff; }
        button.active { background: #7c3aed; border-color: #7c3aed; color: #fff; }
        
        .left-panel { top: 80px; left: 20px; width: 320px; max-height: calc(100vh - 120px); overflow-y: auto; }
        
        .section-title {
            color: #666;
            font-size: 0.7em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 15px 0 8px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .section-title:first-child { margin-top: 0; }
        
        .noc-selector {
            display: flex;
            gap: 0;
            margin-bottom: 10px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .noc-selector button {
            flex: 1;
            border: none;
            border-radius: 0;
            padding: 12px;
            font-weight: bold;
            font-size: 0.85em;
        }
        
        .noc-selector button.noc0 {
            background: #1a1a28;
            color: #00d4ff;
            border-right: 1px solid #333;
        }
        
        .noc-selector button.noc0.active {
            background: #00d4ff;
            color: #000;
        }
        
        .noc-selector button.noc1 {
            background: #1a1a28;
            color: #ff6b00;
        }
        
        .noc-selector button.noc1.active {
            background: #ff6b00;
            color: #000;
        }
        
        .noc-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #666;
            margin-top: 5px;
        }
        
        .status-box {
            background: #12121a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .status-box.noc0-mode {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }
        
        .status-box.noc1-mode {
            border-color: #ff6b00;
            background: rgba(255, 107, 0, 0.1);
        }
        
        .status-box.has-source {
            border-style: dashed;
        }
        
        .status-text {
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        
        .status-hint {
            font-size: 0.7em;
            color: #666;
        }
        
        .pending-source {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .pending-source.noc0 { background: #00d4ff; color: #000; }
        .pending-source.noc1 { background: #ff6b00; color: #000; }
        
        .path-group {
            margin-bottom: 15px;
        }
        
        .path-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .path-group-header.noc0 {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
        }
        
        .path-group-header.noc1 {
            background: rgba(255, 107, 0, 0.2);
            color: #ff6b00;
        }
        
        .path-group-header .count {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85em;
        }
        
        .path-group-header .clear-group {
            background: transparent;
            border: none;
            color: inherit;
            opacity: 0.6;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1em;
        }
        
        .path-group-header .clear-group:hover { opacity: 1; }
        
        .comm-list {
            background: #12121a;
            border-radius: 8px;
            padding: 6px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .comm-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 4px;
            margin: 3px 0;
            background: #1a1a28;
            font-size: 0.75em;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .comm-item:hover {
            background: #252538;
        }
        
        .comm-item.noc0:hover {
            background: rgba(0, 212, 255, 0.15);
        }
        
        .comm-item.noc1:hover {
            background: rgba(255, 107, 0, 0.15);
        }
        
        .comm-item .path-text { flex: 1; }
        .comm-item .hops { 
            color: #888; 
            font-size: 0.9em; 
            min-width: 35px; 
            text-align: right;
        }
        .comm-item.noc0 .hops { color: #00d4ff; }
        .comm-item.noc1 .hops { color: #ff6b00; }
        
        .comm-item .remove-btn {
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.9em;
        }
        
        .comm-item .remove-btn:hover { color: #ef4444; }
        
        .comm-item .switch-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            border-radius: 3px;
            color: #888;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 0.7em;
            font-weight: bold;
            transition: all 0.15s;
        }
        
        .comm-item .switch-btn.better {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
            color: #22c55e;
        }
        
        .comm-item .switch-btn.worse {
            background: rgba(239, 68, 68, 0.1);
            border-color: #666;
            color: #666;
        }
        
        .comm-item.noc0 .switch-btn:hover {
            background: #ff6b00;
            border-color: #ff6b00;
            color: #000;
        }
        
        .comm-item.noc1 .switch-btn:hover {
            background: #00d4ff;
            border-color: #00d4ff;
            color: #000;
        }
        
        .empty-list {
            color: #555;
            font-size: 0.75em;
            text-align: center;
            padding: 12px;
        }
        
        .action-btns {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .action-btns button { flex: 1; }
        
        .clear-btn {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }
        
        .clear-btn:hover { border-color: #ef4444; color: #ef4444; }
        
        .animate-btn {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            border: none;
            color: white;
            font-weight: bold;
        }
        
        .animate-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
        }
        
        .animate-btn.running {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }
        
        .preset-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .preset-btn {
            flex: 1;
            min-width: 60px;
            padding: 6px 8px;
            font-size: 0.7em;
        }
        
        .preset-info {
            background: #12121a;
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 0.7em;
            line-height: 1.4;
            color: #888;
            border-left: 3px solid #666;
        }
        
        .preset-info strong {
            color: #e0e0e0;
        }
        
        .preset-info .noc0-text { color: #00d4ff; }
        .preset-info .noc1-text { color: #ff6b00; }
        
        .right-panel { top: 80px; right: 20px; width: 180px; }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
            font-size: 0.75em;
        }
        
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 4px;
        }
        
        .dram-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            background: #12121a;
            border-radius: 8px;
            padding: 8px;
            margin-top: 8px;
        }
        
        .dram-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7em;
        }
        
        .dram-legend-item .color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .stats-box {
            background: #12121a;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            margin: 4px 0;
        }
        
        .stats-row .label { color: #666; }
        .stats-row .value { font-weight: bold; }
        .stats-row .value.noc0 { color: #00d4ff; }
        .stats-row .value.noc1 { color: #ff6b00; }
        
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.8em;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .tooltip.visible { display: block; }
        
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(8, 8, 15, 0.9);
            border: 1px solid #2a2a40;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 0.8em;
            color: #888;
            z-index: 100;
        }
        
        .instructions .noc0-text { color: #00d4ff; }
        .instructions .noc1-text { color: #ff6b00; }
        .instructions kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
        }

        .visibility-toggles {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }
        
        .vis-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75em;
            cursor: pointer;
        }
        
        .vis-toggle input {
            accent-color: #7c3aed;
        }
        
        .vis-toggle.noc0 { color: #00d4ff; }
        .vis-toggle.noc1 { color: #ff6b00; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="panel top-panel">
        <h1>üåê NOC 2D Torus</h1>
        <div class="btn-group">
            <button id="btn-flat" onclick="setView('flat')">Flat</button>
            <button id="btn-torus" class="active" onclick="setView('torus')">Torus</button>
        </div>
        <div class="btn-group">
            <button onclick="toggleLinks()">Toggle Links</button>
        </div>
    </div>
    
    <div class="panel left-panel">
        <div class="section-title">Add Path To</div>
        <div class="noc-selector">
            <button class="noc0 active" id="sel-noc0" onclick="setActiveNOC('noc0')">
                NOC0 ‚Üí‚Üì
            </button>
            <button class="noc1" id="sel-noc1" onclick="setActiveNOC('noc1')">
                NOC1 ‚Üê‚Üë
            </button>
        </div>
        <div class="noc-info">
            <span>+X, +Y direction</span>
            <span>-X, -Y direction</span>
        </div>
        
        <div class="status-box noc0-mode" id="status-box">
            <div class="status-text" id="status-text">Click a node to set <strong>source</strong></div>
            <div class="status-hint" id="status-hint">Path will be added to NOC0 group</div>
        </div>
        
        <!-- NOC0 Paths -->
        <div class="path-group">
            <div class="path-group-header noc0">
                <span>NOC0 Paths</span>
                <span class="count" id="noc0-count">0</span>
                <button class="clear-group" onclick="clearGroup('noc0')" title="Clear NOC0 paths">√ó</button>
            </div>
            <div class="comm-list" id="noc0-list">
                <div class="empty-list">No NOC0 paths</div>
            </div>
        </div>
        
        <!-- NOC1 Paths -->
        <div class="path-group">
            <div class="path-group-header noc1">
                <span>NOC1 Paths</span>
                <span class="count" id="noc1-count">0</span>
                <button class="clear-group" onclick="clearGroup('noc1')" title="Clear NOC1 paths">√ó</button>
            </div>
            <div class="comm-list" id="noc1-list">
                <div class="empty-list">No NOC1 paths</div>
            </div>
        </div>
        
        <div class="visibility-toggles">
            <label class="vis-toggle noc0">
                <input type="checkbox" id="vis-noc0" checked onchange="updateVisibility()">
                Show NOC0
            </label>
            <label class="vis-toggle noc1">
                <input type="checkbox" id="vis-noc1" checked onchange="updateVisibility()">
                Show NOC1
            </label>
        </div>
        
        <div class="action-btns">
            <button class="clear-btn" onclick="clearAllPaths()">Clear All</button>
            <button class="animate-btn" id="animate-btn" onclick="toggleAnimation()">‚ñ∂ Animate</button>
        </div>
        
        <div class="section-title">Examples</div>
        <div class="preset-btns">
            <button class="preset-btn" onclick="loadPreset('dual-mcast')">Dual Mcast</button>
            <button class="preset-btn" onclick="loadPreset('bidirectional')">Bidirect</button>
            <button class="preset-btn" onclick="loadPreset('pipeline')">Pipeline</button>
        </div>
        <div class="preset-btns" style="margin-top:5px;">
            <button class="preset-btn" onclick="loadPreset('dram-bad')">DRAM (1 noc)</button>
            <button class="preset-btn" onclick="loadPreset('dram-good')">DRAM (2 nocs)</button>
        </div>
        <div class="preset-info" id="preset-info" style="display:none;"></div>
    </div>
    
    <div class="panel right-panel">
        <div class="section-title">Node Types</div>
        <div class="legend-item">
            <div class="legend-color" style="background:#a78bfa"></div>
            <span>Tensix Core</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background:#818cf8"></div>
            <span>Ethernet</span>
        </div>
        
        <div class="section-title">DRAM Banks</div>
        <div class="dram-legend">
            <div class="dram-legend-item"><div class="color" style="background:#4ade80"></div><span>D1</span></div>
            <div class="dram-legend-item"><div class="color" style="background:#22c55e"></div><span>D2</span></div>
            <div class="dram-legend-item"><div class="color" style="background:#86efac"></div><span>D3</span></div>
            <div class="dram-legend-item"><div class="color" style="background:#16a34a"></div><span>D4</span></div>
            <div class="dram-legend-item"><div class="color" style="background:#65d394"></div><span>D5</span></div>
            <div class="dram-legend-item"><div class="color" style="background:#34d399"></div><span>D6</span></div>
        </div>
        
        <div class="section-title">Statistics</div>
        <div class="stats-box">
            <div class="stats-row">
                <span class="label">NOC0 Total Hops</span>
                <span class="value noc0" id="stat-noc0-hops">0</span>
            </div>
            <div class="stats-row">
                <span class="label">NOC1 Total Hops</span>
                <span class="value noc1" id="stat-noc1-hops">0</span>
            </div>
            <div class="stats-row">
                <span class="label">Total Paths</span>
                <span class="value" id="stat-total">0</span>
            </div>
            <div class="stats-row" id="avg-hops-row" style="display:none;">
                <span class="label">Avg Hops/Path</span>
                <span class="value" id="stat-avg-hops">0</span>
            </div>
            <div class="stats-row" id="max-hops-row" style="display:none;">
                <span class="label">Max Hops (Critical)</span>
                <span class="value" id="stat-max-hops">0</span>
            </div>
            <div class="stats-row" id="bw-indicator" style="display:none; margin-top:8px; padding-top:8px; border-top:1px solid #333;">
                <span class="label">Bandwidth</span>
                <span class="value" id="stat-bw" style="color:#22c55e;">2x (Dual NOC)</span>
            </div>
        </div>
        
        <div class="section-title">Keyboard</div>
        <div class="legend-item" style="flex-direction:column; align-items:flex-start; gap:4px; font-size:0.7em;">
            <span><kbd style="background:#333;padding:2px 5px;border-radius:3px;color:#fff">1</kbd> Select NOC0</span>
            <span><kbd style="background:#333;padding:2px 5px;border-radius:3px;color:#fff">2</kbd> Select NOC1</span>
            <span><kbd style="background:#333;padding:2px 5px;border-radius:3px;color:#fff">Space</kbd> Animate</span>
            <span><kbd style="background:#333;padding:2px 5px;border-radius:3px;color:#fff">Esc</kbd> Cancel</span>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <div class="instructions">
        <kbd>1</kbd>/<kbd>2</kbd> select NOC ¬∑ 
        <span class="noc0-text">Click</span> source ‚Üí <span class="noc0-text">Click</span> dest ¬∑ 
        <kbd>Drag</kbd> rotate ¬∑ 
        <kbd>Space</kbd> animate
    </div>

    <script>
        // Constants
        const GRID_W = 10, GRID_H = 12;
        const NOC0_COLOR = 0x00d4ff;
        const NOC1_COLOR = 0xff6b00;
        
        // NOC0 colors - blue/cyan palette
        const NOC0_PALETTE = [
            0x00d4ff, 0x38bdf8, 0x0ea5e9, 0x06b6d4,
            0x22d3ee, 0x67e8f9, 0x00b4d8, 0x0096c7,
            0x48cae4, 0x90e0ef, 0x00b7c3, 0x5eead4
        ];
        
        // NOC1 colors - orange/red palette  
        const NOC1_PALETTE = [
            0xff6b00, 0xf97316, 0xfb923c, 0xf59e0b,
            0xfbbf24, 0xef4444, 0xf87171, 0xff8c42,
            0xffaa5c, 0xffc876, 0xe85d04, 0xdc2f02
        ];
        
        const DRAM_COLORS = {
            'D1': 0x4ade80, 'D2': 0x22c55e, 'D3': 0x86efac,
            'D4': 0x16a34a, 'D5': 0x65d394, 'D6': 0x34d399
        };
        
        const DRAM = [
            {x:0,y:0,b:'D1'},{x:0,y:1,b:'D1'},{x:0,y:11,b:'D1'},
            {x:0,y:5,b:'D2'},{x:0,y:6,b:'D2'},{x:0,y:7,b:'D2'},
            {x:5,y:0,b:'D3'},{x:5,y:1,b:'D3'},{x:5,y:11,b:'D3'},
            {x:5,y:2,b:'D4'},{x:5,y:9,b:'D4'},{x:5,y:10,b:'D4'},
            {x:5,y:3,b:'D5'},{x:5,y:4,b:'D5'},{x:5,y:8,b:'D5'},
            {x:5,y:5,b:'D6'},{x:5,y:6,b:'D6'},{x:5,y:7,b:'D6'}
        ];
        
        // State
        let scene, camera, renderer, raycaster, mouse;
        let nodes = [], noc0Links = [], noc1Links = [], pathMeshes = [], particles = [];
        let viewMode = 'torus';
        let showLinks = true;
        
        // Two separate path groups
        let noc0Paths = [];
        let noc1Paths = [];
        let activeNOC = 'noc0';  // Which NOC new paths are added to
        let pendingSource = null;
        let isAnimating = false;
        
        // Visibility
        let showNoc0Paths = true;
        let showNoc1Paths = true;
        let hoveredNode = null;
        let hoveredPathNoc = null;
        let hoveredPathIdx = null;
        
        function getNodeInfo(x, y) {
            const dram = DRAM.find(d => d.x === x && d.y === y);
            if (dram) return {type: 'dram', label: `${dram.b} (${x},${y})`, color: DRAM_COLORS[dram.b], bank: dram.b};
            if (x === 0 && y === 3) return {type: 'special', label: `PCIe (${x},${y})`, color: 0x4b5563};
            if (x === 0 && y === 10) return {type: 'special', label: `ARC (${x},${y})`, color: 0x4b5563};
            if ([0,6].includes(y) && x > 0 && x !== 5) return {type: 'ethernet', label: `Eth (${x},${y})`, color: 0x818cf8};
            return {type: 'tensix', label: `Core (${x},${y})`, color: 0xa78bfa};
        }
        
        function gridToWorld(x, y) {
            if (viewMode === 'flat') {
                return new THREE.Vector3((x - GRID_W/2) * 5, 0, (y - GRID_H/2) * 4);
            }
            const R = 28, r = 12;
            const u = (x / GRID_W) * Math.PI * 2;
            const v = (y / GRID_H) * Math.PI * 2;
            return new THREE.Vector3(
                (R + r * Math.cos(v)) * Math.cos(u),
                r * Math.sin(v),
                (R + r * Math.cos(v)) * Math.sin(u)
            );
        }
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.Fog(0x050508, 100, 250);
            
            camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 500);
            camera.position.set(55, 35, 55);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            scene.add(new THREE.AmbientLight(0x404060, 0.5));
            const key = new THREE.DirectionalLight(0xffffff, 0.8);
            key.position.set(50, 50, 50);
            scene.add(key);
            
            createNodes();
            createLinks();
            setupControls();
            updateStatus();
            updateStats();
            animate();
        }
        
        function createNodes() {
            nodes.forEach(n => scene.remove(n));
            nodes = [];
            
            const geom = new THREE.SphereGeometry(1.3, 24, 24);
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const info = getNodeInfo(x, y);
                    const isDRAM = info.type === 'dram';
                    const mat = new THREE.MeshPhongMaterial({
                        color: info.color,
                        emissive: info.color,
                        emissiveIntensity: isDRAM ? 0.5 : 0.3,
                        shininess: isDRAM ? 80 : 60
                    });
                    
                    const mesh = new THREE.Mesh(geom, mat);
                    mesh.position.copy(gridToWorld(x, y));
                    mesh.userData = {x, y, info};
                    scene.add(mesh);
                    nodes.push(mesh);
                }
            }
            highlightNodes();
        }
        
        function highlightNodes() {
            const hasHover = hoveredPathNoc !== null && hoveredPathIdx !== null;
            
            nodes.forEach(n => {
                const info = n.userData.info;
                const isDRAM = info.type === 'dram';
                n.material.color.setHex(info.color);
                n.material.emissive.setHex(info.color);
                n.material.emissiveIntensity = isDRAM ? 0.5 : 0.3;
                n.scale.setScalar(1);
                
                // Dim nodes when hovering a path
                if (hasHover) {
                    n.material.emissiveIntensity = isDRAM ? 0.2 : 0.1;
                }
            });
            
            // Highlight NOC0 path endpoints - keep original color, just boost brightness
            if (showNoc0Paths) {
                noc0Paths.forEach((comm, idx) => {
                    const srcNode = nodes.find(n => n.userData.x === comm.src.x && n.userData.y === comm.src.y);
                    const dstNode = nodes.find(n => n.userData.x === comm.dst.x && n.userData.y === comm.dst.y);
                    
                    const isHovered = hoveredPathNoc === 'noc0' && hoveredPathIdx === idx;
                    const intensity = isHovered ? 1.0 : (hasHover ? 0.2 : 0.8);
                    const scale = isHovered ? 1.5 : (hasHover ? 1.0 : 1.15);
                    
                    if (srcNode) {
                        srcNode.material.emissiveIntensity = intensity;
                        srcNode.scale.setScalar(scale);
                    }
                    if (dstNode) {
                        dstNode.material.emissiveIntensity = intensity;
                        dstNode.scale.setScalar(scale);
                    }
                });
            }
            
            // Highlight NOC1 path endpoints - keep original color, just boost brightness
            if (showNoc1Paths) {
                noc1Paths.forEach((comm, idx) => {
                    const srcNode = nodes.find(n => n.userData.x === comm.src.x && n.userData.y === comm.src.y);
                    const dstNode = nodes.find(n => n.userData.x === comm.dst.x && n.userData.y === comm.dst.y);
                    
                    const isHovered = hoveredPathNoc === 'noc1' && hoveredPathIdx === idx;
                    const intensity = isHovered ? 1.0 : (hasHover ? 0.2 : 0.8);
                    const scale = isHovered ? 1.5 : (hasHover ? 1.0 : 1.15);
                    
                    if (srcNode) {
                        srcNode.material.emissiveIntensity = intensity;
                        srcNode.scale.setScalar(scale);
                    }
                    if (dstNode) {
                        dstNode.material.emissiveIntensity = intensity;
                        dstNode.scale.setScalar(scale);
                    }
                });
            }
            
            // Highlight pending source
            if (pendingSource) {
                const srcNode = nodes.find(n => n.userData.x === pendingSource.x && n.userData.y === pendingSource.y);
                if (srcNode) {
                    srcNode.material.emissive.setHex(activeNOC === 'noc0' ? NOC0_COLOR : NOC1_COLOR);
                    srcNode.material.emissiveIntensity = 1;
                    srcNode.scale.setScalar(1.6);
                }
            }
        }
        
        function applyHoverEffect(node) {
            if (!node) return;
            
            // Store original values if not already stored
            if (!node.userData.originalScale) {
                node.userData.originalScale = node.scale.x;
                node.userData.originalEmissiveIntensity = node.material.emissiveIntensity;
            }
            
            // Apply hover: slight scale increase and brightness boost
            const scaleBoost = 1.15;
            const brightnessBoost = 0.3;
            
            node.scale.setScalar(node.userData.originalScale * scaleBoost);
            node.material.emissiveIntensity = Math.min(1, node.userData.originalEmissiveIntensity + brightnessBoost);
        }
        
        function resetNodeAppearance(node) {
            if (!node) return;
            
            // Restore original values and re-run highlight logic
            delete node.userData.originalScale;
            delete node.userData.originalEmissiveIntensity;
            highlightNodes();
        }
        
        function createLinks() {
            [...noc0Links, ...noc1Links].forEach(l => scene.remove(l));
            noc0Links = [];
            noc1Links = [];
            
            const tubeRadius = 0.1;
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const p = gridToWorld(x, y);
                    
                    const nx = (x + 1) % GRID_W;
                    const pRight = gridToWorld(nx, y);
                    const tube0x = new THREE.Mesh(
                        new THREE.TubeGeometry(new THREE.LineCurve3(p, pRight), 1, tubeRadius, 8),
                        new THREE.MeshBasicMaterial({color: NOC0_COLOR, transparent: true, opacity: 0.2})
                    );
                    scene.add(tube0x);
                    noc0Links.push(tube0x);
                    
                    const ny = (y + 1) % GRID_H;
                    const pDown = gridToWorld(x, ny);
                    const tube0y = new THREE.Mesh(
                        new THREE.TubeGeometry(new THREE.LineCurve3(p, pDown), 1, tubeRadius, 8),
                        new THREE.MeshBasicMaterial({color: NOC0_COLOR, transparent: true, opacity: 0.2})
                    );
                    scene.add(tube0y);
                    noc0Links.push(tube0y);
                    
                    const offset = new THREE.Vector3(0, 0.5, 0);
                    const pOff = p.clone().add(offset);
                    const px = (x - 1 + GRID_W) % GRID_W;
                    const pLeft = gridToWorld(px, y).add(offset.clone());
                    const tube1x = new THREE.Mesh(
                        new THREE.TubeGeometry(new THREE.LineCurve3(pOff, pLeft), 1, tubeRadius, 8),
                        new THREE.MeshBasicMaterial({color: NOC1_COLOR, transparent: true, opacity: 0.2})
                    );
                    scene.add(tube1x);
                    noc1Links.push(tube1x);
                    
                    const py = (y - 1 + GRID_H) % GRID_H;
                    const pUp = gridToWorld(x, py).add(offset.clone());
                    const tube1y = new THREE.Mesh(
                        new THREE.TubeGeometry(new THREE.LineCurve3(pOff, pUp), 1, tubeRadius, 8),
                        new THREE.MeshBasicMaterial({color: NOC1_COLOR, transparent: true, opacity: 0.2})
                    );
                    scene.add(tube1y);
                    noc1Links.push(tube1y);
                }
            }
            
            updateLinkVisibility();
        }
        
        function toggleLinks() {
            showLinks = !showLinks;
            updateLinkVisibility();
        }
        
        function updateLinkVisibility() {
            noc0Links.forEach(l => l.visible = showLinks);
            noc1Links.forEach(l => l.visible = showLinks);
        }
        
        function calcPath(src, dst, noc) {
            const path = [{...src}];
            let curr = {...src};
            let hops = 0;
            
            let xHops, yHops;
            
            if (noc === 'noc0') {
                xHops = dst.x >= src.x ? dst.x - src.x : (GRID_W - src.x) + dst.x;
                yHops = dst.y >= src.y ? dst.y - src.y : (GRID_H - src.y) + dst.y;
            } else {
                xHops = dst.x <= src.x ? src.x - dst.x : src.x + (GRID_W - dst.x);
                yHops = dst.y <= src.y ? src.y - dst.y : src.y + (GRID_H - dst.y);
            }
            
            const xDir = (noc === 'noc0') ? 1 : -1;
            const yDir = (noc === 'noc0') ? 1 : -1;
            
            for (let i = 0; i < xHops; i++) {
                curr.x = (curr.x + xDir + GRID_W) % GRID_W;
                path.push({...curr});
                hops++;
            }
            
            for (let i = 0; i < yHops; i++) {
                curr.y = (curr.y + yDir + GRID_H) % GRID_H;
                path.push({...curr});
                hops++;
            }
            
            return {path, hops};
        }
        
        function updatePaths() {
            pathMeshes.forEach(m => scene.remove(m));
            pathMeshes = [];
            
            const hasHover = hoveredPathNoc !== null && hoveredPathIdx !== null;
            
            // Draw NOC0 paths with unique blue-ish colors
            if (showNoc0Paths) {
                noc0Paths.forEach((comm, idx) => {
                    const color = NOC0_PALETTE[idx % NOC0_PALETTE.length];
                    const isHovered = hoveredPathNoc === 'noc0' && hoveredPathIdx === idx;
                    const dimmed = hasHover && !isHovered;
                    drawPath(comm.src, comm.dst, 'noc0', color, isHovered, dimmed);
                });
            }
            
            // Draw NOC1 paths with unique orange-ish colors
            if (showNoc1Paths) {
                noc1Paths.forEach((comm, idx) => {
                    const color = NOC1_PALETTE[idx % NOC1_PALETTE.length];
                    const isHovered = hoveredPathNoc === 'noc1' && hoveredPathIdx === idx;
                    const dimmed = hasHover && !isHovered;
                    drawPath(comm.src, comm.dst, 'noc1', color, isHovered, dimmed);
                });
            }
        }
        
        function drawPath(src, dst, noc, color, isHovered = false, dimmed = false) {
            const pathData = calcPath(src, dst, noc);
            const yOffset = noc === 'noc1' ? 0.5 : 0;
            const points = pathData.path.map(p => {
                const pos = gridToWorld(p.x, p.y);
                pos.y += yOffset;
                return pos;
            });
            
            // Adjust appearance based on hover state
            const tubeRadius = isHovered ? 0.35 : (dimmed ? 0.12 : 0.2);
            const opacity = isHovered ? 1.0 : (dimmed ? 0.15 : 0.85);
            
            for (let i = 0; i < points.length - 1; i++) {
                const curve = new THREE.LineCurve3(points[i], points[i+1]);
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 8, tubeRadius, 8),
                    new THREE.MeshBasicMaterial({color, transparent: true, opacity})
                );
                scene.add(tube);
                pathMeshes.push(tube);
            }
            
            if (points.length >= 2) {
                const dir = new THREE.Vector3().subVectors(points[points.length-1], points[points.length-2]).normalize();
                const arrowLength = isHovered ? 3 : 2;
                const headLength = isHovered ? 2 : 1.5;
                const headWidth = isHovered ? 1.2 : 0.8;
                const arrow = new THREE.ArrowHelper(dir, points[points.length-1], arrowLength, color, headLength, headWidth);
                if (dimmed) {
                    arrow.line.material.opacity = opacity;
                    arrow.line.material.transparent = true;
                    arrow.cone.material.opacity = opacity;
                    arrow.cone.material.transparent = true;
                }
                scene.add(arrow);
                pathMeshes.push(arrow);
            }
        }
        
        function setActiveNOC(noc) {
            activeNOC = noc;
            document.getElementById('sel-noc0').classList.toggle('active', noc === 'noc0');
            document.getElementById('sel-noc1').classList.toggle('active', noc === 'noc1');
            updateStatus();
            highlightNodes();
        }
        
        function updateStatus() {
            const box = document.getElementById('status-box');
            const text = document.getElementById('status-text');
            const hint = document.getElementById('status-hint');
            
            box.className = 'status-box';
            box.classList.add(activeNOC === 'noc0' ? 'noc0-mode' : 'noc1-mode');
            
            if (pendingSource) {
                box.classList.add('has-source');
                const nocClass = activeNOC === 'noc0' ? 'noc0' : 'noc1';
                text.innerHTML = `Source: <span class="pending-source ${nocClass}">(${pendingSource.x}, ${pendingSource.y})</span>`;
                hint.textContent = 'Click destination node';
            } else {
                text.innerHTML = 'Click a node to set <strong>source</strong>';
                hint.textContent = `Path will be added to ${activeNOC.toUpperCase()} group`;
            }
        }
        
        function updateCommLists() {
            // NOC0 list
            const noc0List = document.getElementById('noc0-list');
            document.getElementById('noc0-count').textContent = noc0Paths.length;
            
            if (noc0Paths.length === 0) {
                noc0List.innerHTML = '<div class="empty-list">No NOC0 paths</div>';
            } else {
                noc0List.innerHTML = noc0Paths.map((comm, idx) => {
                    const noc0Hops = calcPath(comm.src, comm.dst, 'noc0').hops;
                    const noc1Hops = calcPath(comm.src, comm.dst, 'noc1').hops;
                    const diff = noc1Hops - noc0Hops;
                    const diffText = diff > 0 ? `+${diff}` : diff.toString();
                    const betterClass = diff < 0 ? 'better' : (diff > 0 ? 'worse' : '');
                    return `<div class="comm-item noc0" onmouseenter="hoverPath('noc0', ${idx})" onmouseleave="unhoverPath()">
                        <div class="path-text">(${comm.src.x},${comm.src.y})‚Üí(${comm.dst.x},${comm.dst.y})</div>
                        <div class="hops">${noc0Hops} hops</div>
                        <button class="switch-btn ${betterClass}" onclick="event.stopPropagation(); switchPath('noc0', ${idx})" title="Move to NOC1 (${noc1Hops} hops, ${diffText})">‚Üí1</button>
                        <button class="remove-btn" onclick="event.stopPropagation(); removePath('noc0', ${idx})">√ó</button>
                    </div>`;
                }).join('');
            }
            
            // NOC1 list
            const noc1List = document.getElementById('noc1-list');
            document.getElementById('noc1-count').textContent = noc1Paths.length;
            
            if (noc1Paths.length === 0) {
                noc1List.innerHTML = '<div class="empty-list">No NOC1 paths</div>';
            } else {
                noc1List.innerHTML = noc1Paths.map((comm, idx) => {
                    const noc0Hops = calcPath(comm.src, comm.dst, 'noc0').hops;
                    const noc1Hops = calcPath(comm.src, comm.dst, 'noc1').hops;
                    const diff = noc0Hops - noc1Hops;
                    const diffText = diff > 0 ? `+${diff}` : diff.toString();
                    const betterClass = diff < 0 ? 'better' : (diff > 0 ? 'worse' : '');
                    return `<div class="comm-item noc1" onmouseenter="hoverPath('noc1', ${idx})" onmouseleave="unhoverPath()">
                        <div class="path-text">(${comm.src.x},${comm.src.y})‚Üí(${comm.dst.x},${comm.dst.y})</div>
                        <div class="hops">${noc1Hops} hops</div>
                        <button class="switch-btn ${betterClass}" onclick="event.stopPropagation(); switchPath('noc1', ${idx})" title="Move to NOC0 (${noc0Hops} hops, ${diffText})">‚Üí0</button>
                        <button class="remove-btn" onclick="event.stopPropagation(); removePath('noc1', ${idx})">√ó</button>
                    </div>`;
                }).join('');
            }
        }
        
        function updateStats() {
            let noc0Hops = 0, noc1Hops = 0;
            let maxHops = 0;
            
            noc0Paths.forEach(comm => {
                const hops = calcPath(comm.src, comm.dst, 'noc0').hops;
                noc0Hops += hops;
                maxHops = Math.max(maxHops, hops);
            });
            
            noc1Paths.forEach(comm => {
                const hops = calcPath(comm.src, comm.dst, 'noc1').hops;
                noc1Hops += hops;
                maxHops = Math.max(maxHops, hops);
            });
            
            const totalHops = noc0Hops + noc1Hops;
            const totalPaths = noc0Paths.length + noc1Paths.length;
            
            document.getElementById('stat-noc0-hops').textContent = noc0Hops;
            document.getElementById('stat-noc1-hops').textContent = noc1Hops;
            document.getElementById('stat-total').textContent = totalPaths;
            
            // Show average hops
            const avgHopsRow = document.getElementById('avg-hops-row');
            const avgHopsStat = document.getElementById('stat-avg-hops');
            const maxHopsRow = document.getElementById('max-hops-row');
            const maxHopsStat = document.getElementById('stat-max-hops');
            
            if (totalPaths > 0) {
                avgHopsRow.style.display = 'flex';
                maxHopsRow.style.display = 'flex';
                
                const avg = totalHops / totalPaths;
                avgHopsStat.textContent = avg.toFixed(1);
                maxHopsStat.textContent = maxHops;
                
                // Color based on efficiency
                if (avg <= 4) {
                    avgHopsStat.style.color = '#22c55e';
                } else if (avg <= 7) {
                    avgHopsStat.style.color = '#eab308';
                } else {
                    avgHopsStat.style.color = '#ef4444';
                }
                
                if (maxHops <= 5) {
                    maxHopsStat.style.color = '#22c55e';
                } else if (maxHops <= 10) {
                    maxHopsStat.style.color = '#eab308';
                } else {
                    maxHopsStat.style.color = '#ef4444';
                }
            } else {
                avgHopsRow.style.display = 'none';
                maxHopsRow.style.display = 'none';
            }
            
            // Show bandwidth indicator
            const bwIndicator = document.getElementById('bw-indicator');
            const bwStat = document.getElementById('stat-bw');
            
            if (totalPaths > 0) {
                bwIndicator.style.display = 'flex';
                
                if (noc0Paths.length > 0 && noc1Paths.length > 0) {
                    const balance = Math.min(noc0Paths.length, noc1Paths.length) / Math.max(noc0Paths.length, noc1Paths.length);
                    const effectiveBW = 1 + balance;
                    bwStat.textContent = `${effectiveBW.toFixed(1)}x (Dual NOC)`;
                    bwStat.style.color = '#22c55e';
                } else {
                    bwStat.textContent = '1x (Single NOC)';
                    bwStat.style.color = '#ef4444';
                }
            } else {
                bwIndicator.style.display = 'none';
            }
        }
        
        function updateVisibility() {
            showNoc0Paths = document.getElementById('vis-noc0').checked;
            showNoc1Paths = document.getElementById('vis-noc1').checked;
            highlightNodes();
            updatePaths();
            
            if (isAnimating) {
                stopAnim();
                startAnim();
            }
        }
        
        function hoverPath(noc, idx) {
            hoveredPathNoc = noc;
            hoveredPathIdx = idx;
            updatePaths();
            highlightNodes();
        }
        
        function unhoverPath() {
            hoveredPathNoc = null;
            hoveredPathIdx = null;
            updatePaths();
            highlightNodes();
        }
        
        function handleNodeClick(x, y) {
            if (!pendingSource) {
                pendingSource = {x, y};
                highlightNodes();
                updateStatus();
            } else {
                if (x === pendingSource.x && y === pendingSource.y) {
                    pendingSource = null;
                    highlightNodes();
                    updateStatus();
                    return;
                }
                
                const newPath = {
                    src: {...pendingSource},
                    dst: {x, y},
                    id: Date.now()
                };
                
                if (activeNOC === 'noc0') {
                    noc0Paths.push(newPath);
                } else {
                    noc1Paths.push(newPath);
                }
                
                pendingSource = null;
                
                // Clear hover state
                hoveredPathNoc = null;
                hoveredPathIdx = null;
                
                updateStatus();
                updateCommLists();
                updateStats();
                highlightNodes();
                updatePaths();
                
                if (isAnimating) {
                    stopAnim();
                    startAnim();
                }
            }
        }
        
        function cancelPending() {
            pendingSource = null;
            highlightNodes();
            updateStatus();
        }
        
        function removePath(noc, idx) {
            if (noc === 'noc0') {
                noc0Paths.splice(idx, 1);
            } else {
                noc1Paths.splice(idx, 1);
            }
            
            // Clear hover state
            hoveredPathNoc = null;
            hoveredPathIdx = null;
            
            updateCommLists();
            updateStats();
            highlightNodes();
            updatePaths();
            
            if (isAnimating) {
                stopAnim();
                if (noc0Paths.length + noc1Paths.length > 0) startAnim();
            }
        }
        
        function switchPath(fromNoc, idx) {
            let path;
            if (fromNoc === 'noc0') {
                path = noc0Paths.splice(idx, 1)[0];
                noc1Paths.push(path);
            } else {
                path = noc1Paths.splice(idx, 1)[0];
                noc0Paths.push(path);
            }
            
            // Clear hover state
            hoveredPathNoc = null;
            hoveredPathIdx = null;
            
            updateCommLists();
            updateStats();
            highlightNodes();
            updatePaths();
            
            if (isAnimating) {
                stopAnim();
                startAnim();
            }
        }
        
        function clearGroup(noc) {
            if (noc === 'noc0') {
                noc0Paths = [];
            } else {
                noc1Paths = [];
            }
            
            // Clear hover state
            hoveredPathNoc = null;
            hoveredPathIdx = null;
            
            updateCommLists();
            updateStats();
            highlightNodes();
            updatePaths();
            
            if (isAnimating) {
                stopAnim();
                if (noc0Paths.length + noc1Paths.length > 0) startAnim();
            }
        }
        
        function clearAllPaths() {
            noc0Paths = [];
            noc1Paths = [];
            pendingSource = null;
            
            // Clear hover state
            hoveredPathNoc = null;
            hoveredPathIdx = null;
            
            updateStatus();
            updateCommLists();
            updateStats();
            highlightNodes();
            updatePaths();
            stopAnim();
        }
        
        function loadPreset(name) {
            clearAllPaths();
            
            const infoPanel = document.getElementById('preset-info');
            infoPanel.style.display = 'none';
            
            switch(name) {
                case 'dual-mcast':
                    // NOC0: horizontal multicast (going right)
                    for (let x = 2; x <= 5; x++) {
                        noc0Paths.push({src: {x: 1, y: 3}, dst: {x, y: 3}, id: Date.now() + x});
                    }
                    // NOC1: vertical multicast (going up)
                    for (let y = 1; y <= 4; y++) {
                        noc1Paths.push({src: {x: 7, y: 5}, dst: {x: 7, y}, id: Date.now() + 100 + y});
                    }
                    
                    infoPanel.innerHTML = `
                        <strong>Dual Multicast</strong><br>
                        <span class="noc0-text">NOC0:</span> Horizontal mcast (going +X)<br>
                        <span class="noc1-text">NOC1:</span> Vertical mcast (going -Y)<br>
                        <br>
                        Independent broadcast operations on each NOC.
                    `;
                    infoPanel.style.display = 'block';
                    break;
                    
                case 'bidirectional':
                    // Ring with opposing directions
                    // NOC0: clockwise part (right and down)
                    noc0Paths.push({src: {x: 2, y: 2}, dst: {x: 4, y: 2}, id: Date.now()});
                    noc0Paths.push({src: {x: 4, y: 2}, dst: {x: 4, y: 4}, id: Date.now() + 1});
                    // NOC1: counter-clockwise part (left and up)
                    noc1Paths.push({src: {x: 4, y: 4}, dst: {x: 2, y: 4}, id: Date.now() + 2});
                    noc1Paths.push({src: {x: 2, y: 4}, dst: {x: 2, y: 2}, id: Date.now() + 3});
                    
                    infoPanel.innerHTML = `
                        <strong>Bidirectional Ring</strong><br>
                        <span class="noc0-text">NOC0:</span> Clockwise (right‚Üídown)<br>
                        <span class="noc1-text">NOC1:</span> Counter-clockwise (left‚Üíup)<br>
                        <br>
                        Full-duplex communication around the ring.
                    `;
                    infoPanel.style.display = 'block';
                    break;
                    
                case 'pipeline':
                    // Stage 1 ‚Üí Stage 2 via NOC0
                    noc0Paths.push({src: {x: 1, y: 2}, dst: {x: 3, y: 2}, id: Date.now()});
                    noc0Paths.push({src: {x: 1, y: 3}, dst: {x: 3, y: 3}, id: Date.now() + 1});
                    // Stage 2 ‚Üí Stage 3 via NOC0
                    noc0Paths.push({src: {x: 3, y: 2}, dst: {x: 6, y: 2}, id: Date.now() + 2});
                    noc0Paths.push({src: {x: 3, y: 3}, dst: {x: 6, y: 3}, id: Date.now() + 3});
                    // Results back via NOC1 (going left)
                    noc1Paths.push({src: {x: 6, y: 2}, dst: {x: 1, y: 2}, id: Date.now() + 4});
                    noc1Paths.push({src: {x: 6, y: 3}, dst: {x: 1, y: 3}, id: Date.now() + 5});
                    
                    infoPanel.innerHTML = `
                        <strong>Pipeline with Return Path</strong><br>
                        <span class="noc0-text">NOC0:</span> Forward data flow (Stage1‚Üí2‚Üí3)<br>
                        <span class="noc1-text">NOC1:</span> Results return path<br>
                        <br>
                        Uses natural directions: forward goes +X, return goes -X.
                    `;
                    infoPanel.style.display = 'block';
                    break;
                    
                case 'dram-bad':
                    // BAD: Naive DRAM interleaved - all reads on NOC0 only
                    // Each core reads tile from DRAM bank = core_index % 6
                    // This ignores NOC topology and wastes NOC1
                    
                    // All 6 DRAM bank entry points (one per bank)
                    const dramBanks = [
                        {x:0, y:0, bank:'D1'},   // D1
                        {x:0, y:5, bank:'D2'},   // D2
                        {x:5, y:0, bank:'D3'},   // D3
                        {x:5, y:2, bank:'D4'},   // D4
                        {x:5, y:3, bank:'D5'},   // D5
                        {x:5, y:5, bank:'D6'}    // D6
                    ];
                    
                    // Get ALL Tensix worker cores
                    const allCores = [];
                    for (let y = 0; y < GRID_H; y++) {
                        for (let x = 0; x < GRID_W; x++) {
                            const info = getNodeInfo(x, y);
                            if (info.type === 'tensix') {
                                allCores.push({x, y});
                            }
                        }
                    }
                    
                    // Naive assignment: core_index % 6 determines DRAM bank, ALL on NOC0
                    allCores.forEach((core, idx) => {
                        const dramIdx = idx % 6;
                        const dram = dramBanks[dramIdx];
                        noc0Paths.push({
                            src: {x: dram.x, y: dram.y},
                            dst: {x: core.x, y: core.y},
                            id: Date.now() + idx
                        });
                    });
                    
                    infoPanel.innerHTML = `
                        <strong>DRAM Interleaved (1 NOC)</strong><br><br>
                        <code>bank = core_idx % 6</code><br>
                        <span class="noc0-text">All ${allCores.length} cores read via NOC0 only</span><br><br>
                        <strong>Problems:</strong><br>
                        ‚Ä¢ Right DRAM ‚Üí Left cores: long wrap paths<br>
                        ‚Ä¢ Left DRAM ‚Üí Right cores: inefficient<br>
                        ‚Ä¢ NOC1 sits <strong>completely idle</strong><br>
                        ‚Ä¢ <strong>50% bandwidth wasted</strong>
                    `;
                    infoPanel.style.display = 'block';
                    break;
                    
                case 'dram-good':
                    // OPTIMAL: Each DRAM group serves cores on BOTH sides using BOTH NOCs
                    // This is the key insight: use topology to minimize hops
                    
                    // Left DRAM nodes (x=0): D1, D2
                    const leftDramAll = [
                        {x:0, y:0}, {x:0, y:1}, {x:0, y:11},  // D1
                        {x:0, y:5}, {x:0, y:6}, {x:0, y:7}    // D2
                    ];
                    
                    // Right DRAM nodes (x=5): D3, D4, D5, D6
                    const rightDramAll = [
                        {x:5, y:0}, {x:5, y:1}, {x:5, y:11},  // D3
                        {x:5, y:2}, {x:5, y:9}, {x:5, y:10},  // D4
                        {x:5, y:3}, {x:5, y:4}, {x:5, y:8},   // D5
                        {x:5, y:5}, {x:5, y:6}, {x:5, y:7}    // D6
                    ];
                    
                    // Get ALL Tensix worker cores
                    const allCoresGood = [];
                    for (let y = 0; y < GRID_H; y++) {
                        for (let x = 0; x < GRID_W; x++) {
                            const info = getNodeInfo(x, y);
                            if (info.type === 'tensix') {
                                allCoresGood.push({x, y});
                            }
                        }
                    }
                    
                    let leftDramIdx = 0, rightDramIdx = 0;
                    
                    // Strategy:
                    // LEFT DRAM (x=0):
                    //   - NOC0 (+X): serves cores x=1,2 (1-2 hops direct)
                    //   - NOC1 (-X wrap): serves cores x=8,9 (2-1 hops via wrap!)
                    // RIGHT DRAM (x=5):
                    //   - NOC0 (+X): serves cores x=6,7 (1-2 hops direct)
                    //   - NOC1 (-X): serves cores x=3,4 (2-1 hops direct)
                    
                    allCoresGood.forEach((core, idx) => {
                        let dram, noc;
                        
                        if (core.x === 1 || core.x === 2) {
                            // Near left DRAM, use NOC0 going right
                            dram = leftDramAll[leftDramIdx++ % leftDramAll.length];
                            noc = 'noc0';
                        } else if (core.x === 3 || core.x === 4) {
                            // Near right DRAM, use NOC1 going left
                            dram = rightDramAll[rightDramIdx++ % rightDramAll.length];
                            noc = 'noc1';
                        } else if (core.x === 6 || core.x === 7) {
                            // Near right DRAM, use NOC0 going right
                            dram = rightDramAll[rightDramIdx++ % rightDramAll.length];
                            noc = 'noc0';
                        } else if (core.x === 8 || core.x === 9) {
                            // Far from both, but left DRAM via NOC1 wrap is shorter!
                            // x=0 to x=9 via NOC1: 0‚Üí9 = 1 hop
                            // x=0 to x=8 via NOC1: 0‚Üí9‚Üí8 = 2 hops
                            dram = leftDramAll[leftDramIdx++ % leftDramAll.length];
                            noc = 'noc1';
                        } else {
                            // Fallback for any other x (shouldn't happen much)
                            dram = rightDramAll[rightDramIdx++ % rightDramAll.length];
                            noc = 'noc0';
                        }
                        
                        if (noc === 'noc0') {
                            noc0Paths.push({
                                src: {x: dram.x, y: dram.y},
                                dst: {x: core.x, y: core.y},
                                id: Date.now() + idx
                            });
                        } else {
                            noc1Paths.push({
                                src: {x: dram.x, y: dram.y},
                                dst: {x: core.x, y: core.y},
                                id: Date.now() + 1000 + idx
                            });
                        }
                    });
                    
                    infoPanel.innerHTML = `
                        <strong>DRAM Interleaved (2 NOCs)</strong><br><br>
                        <strong>Left DRAM (x=0):</strong><br>
                        <span class="noc0-text">NOC0 ‚Üí</span> cores x=1,2 (1-2 hops)<br>
                        <span class="noc1-text">NOC1 ‚Üí</span> cores x=8,9 (1-2 hops via wrap!)<br><br>
                        <strong>Right DRAM (x=5):</strong><br>
                        <span class="noc0-text">NOC0 ‚Üí</span> cores x=6,7 (1-2 hops)<br>
                        <span class="noc1-text">NOC1 ‚Üí</span> cores x=3,4 (1-2 hops)<br><br>
                        <strong>Result:</strong> All paths ‚â§2 X-hops, 2x bandwidth
                    `;
                    infoPanel.style.display = 'block';
                    break;
            }
            
            updateCommLists();
            updateStats();
            highlightNodes();
            updatePaths();
        }
        
        function setView(mode) {
            viewMode = mode;
            document.getElementById('btn-flat').classList.toggle('active', mode === 'flat');
            document.getElementById('btn-torus').classList.toggle('active', mode === 'torus');
            createNodes();
            createLinks();
            updatePaths();
            camera.position.set(mode === 'flat' ? 0 : 55, mode === 'flat' ? 70 : 35, mode === 'flat' ? 50 : 55);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleAnimation() {
            isAnimating ? stopAnim() : startAnim();
        }
        
        function startAnim() {
            if (noc0Paths.length + noc1Paths.length === 0) return;
            
            isAnimating = true;
            document.getElementById('animate-btn').textContent = '‚èπ Stop';
            document.getElementById('animate-btn').classList.add('running');
            
            // NOC0 particles with unique blue-ish colors
            if (showNoc0Paths) {
                noc0Paths.forEach((comm, idx) => {
                    const pathData = calcPath(comm.src, comm.dst, 'noc0');
                    const color = NOC0_PALETTE[idx % NOC0_PALETTE.length];
                    createParticles(pathData.path, 0, color, idx);
                });
            }
            
            // NOC1 particles with unique orange-ish colors
            if (showNoc1Paths) {
                noc1Paths.forEach((comm, idx) => {
                    const pathData = calcPath(comm.src, comm.dst, 'noc1');
                    const color = NOC1_PALETTE[idx % NOC1_PALETTE.length];
                    createParticles(pathData.path, 0.5, color, idx + 100);
                });
            }
            
            let frame = 0;
            const speed = 0.12;
            
            function tick() {
                if (!isAnimating) return;
                frame++;
                
                particles.forEach((p, idx) => {
                    const path = p.userData.path;
                    const yOffset = p.userData.yOffset;
                    const total = Math.max(path.length, 10) / speed;
                    const progress = ((frame + p.userData.offset) % total) * speed;
                    const pi = Math.floor(progress);
                    const t = progress - pi;
                    
                    if (pi < path.length - 1) {
                        const a = gridToWorld(path[pi].x, path[pi].y);
                        const b = gridToWorld(path[pi+1].x, path[pi+1].y);
                        p.position.lerpVectors(a, b, t);
                        p.position.y += yOffset;
                        p.visible = true;
                    } else {
                        p.visible = false;
                    }
                    
                    const s = 1 + 0.2 * Math.sin(frame * 0.15 + idx);
                    p.scale.setScalar(s);
                });
                
                requestAnimationFrame(tick);
            }
            tick();
        }
        
        function createParticles(path, yOffset, color, commIdx) {
            for (let i = 0; i < 3; i++) {
                const geom = new THREE.SphereGeometry(0.5, 16, 16);
                const mat = new THREE.MeshBasicMaterial({color});
                const p = new THREE.Mesh(geom, mat);
                p.userData = {
                    offset: i * 8 + commIdx * 3,
                    path,
                    yOffset
                };
                
                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(1.0, 16, 16),
                    new THREE.MeshBasicMaterial({color, transparent: true, opacity: 0.2})
                );
                p.add(glow);
                
                scene.add(p);
                particles.push(p);
            }
        }
        
        function stopAnim() {
            isAnimating = false;
            document.getElementById('animate-btn').textContent = '‚ñ∂ Animate';
            document.getElementById('animate-btn').classList.remove('running');
            particles.forEach(p => scene.remove(p));
            particles = [];
        }
        
        function setupControls() {
            let dragging = false, dragMoved = false, prev = {x:0, y:0};
            
            renderer.domElement.addEventListener('mousedown', e => {
                dragging = true;
                dragMoved = false;
                prev = {x: e.clientX, y: e.clientY};
            });
            
            renderer.domElement.addEventListener('mouseup', e => {
                if (!dragMoved) {
                    raycaster.setFromCamera(mouse, camera);
                    const hits = raycaster.intersectObjects(nodes);
                    
                    if (hits.length > 0) {
                        const node = hits[0].object;
                        handleNodeClick(node.userData.x, node.userData.y);
                    }
                }
                dragging = false;
            });
            
            renderer.domElement.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / innerHeight) * 2 + 1;
                
                if (dragging) {
                    const dx = e.clientX - prev.x;
                    const dy = e.clientY - prev.y;
                    
                    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                        dragMoved = true;
                    }
                    
                    const sph = new THREE.Spherical().setFromVector3(camera.position);
                    sph.theta -= dx * 0.008;
                    sph.phi -= dy * 0.008;
                    sph.phi = Math.max(0.2, Math.min(Math.PI - 0.2, sph.phi));
                    camera.position.setFromSpherical(sph);
                    camera.lookAt(0, 0, 0);
                    
                    prev = {x: e.clientX, y: e.clientY};
                } else {
                    raycaster.setFromCamera(mouse, camera);
                    const hits = raycaster.intersectObjects(nodes);
                    const tooltip = document.getElementById('tooltip');
                    
                    // Reset previous hover
                    if (hoveredNode && (!hits.length || hits[0].object !== hoveredNode)) {
                        resetNodeAppearance(hoveredNode);
                        hoveredNode = null;
                    }
                    
                    if (hits.length > 0) {
                        const node = hits[0].object;
                        tooltip.textContent = node.userData.info.label;
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';
                        tooltip.classList.add('visible');
                        
                        // Apply hover effect
                        if (node !== hoveredNode) {
                            hoveredNode = node;
                            applyHoverEffect(node);
                        }
                    } else {
                        tooltip.classList.remove('visible');
                    }
                }
            });
            
            renderer.domElement.addEventListener('wheel', e => {
                const d = camera.position.length();
                const nd = Math.max(30, Math.min(150, d + e.deltaY * 0.08));
                camera.position.normalize().multiplyScalar(nd);
            });
            
            document.addEventListener('keydown', e => {
                if (e.key === ' ') { e.preventDefault(); toggleAnimation(); }
                if (e.key === '1') setActiveNOC('noc0');
                if (e.key === '2') setActiveNOC('noc1');
                if (e.key === 'Escape') cancelPending();
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
        
        init();
    </script>
</body>
</html>
